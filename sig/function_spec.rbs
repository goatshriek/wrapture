module Wrapture
  class FunctionSpec
    include Named

    @owner: Wrapture::ClassSpec | Wrapture::Scope
    @spec: spec_hash
    @wrapped: Wrapture::WrappedFunctionSpec | Wrapture::WrappedCodeSpec | nil
    @params: Array[Wrapture::ParamSpec]
    @constructor: bool
    @destructor: bool

    def self.normalize_return_hash: (spec_hash spec) -> spec_hash
    def self.normalize_spec_hash: (spec_hash spec) -> spec_hash
    def self.normalize_spec_hash!: (spec_hash spec) -> spec_hash
    def initialize: (spec_hash spec, ?(Wrapture::ClassSpec | Wrapture::Scope) owner, ?constructor: bool, ?destructor: bool) -> void
    attr_reader owner: Wrapture::ClassSpec | Wrapture::Scope
    attr_reader params: Array[Wrapture::ParamSpec]
    attr_reader return_type: Wrapture::TypeSpec
    attr_reader wrapped: Wrapture::WrappedFunctionSpec | Wrapture::WrappedCodeSpec | nil
    def constructor?: -> bool
    def declaration_includes: -> Array[String]
    def definable?: -> bool
    def definable!: -> true
    def definition_includes: -> Array[String]
    def destructor?: -> bool
    def doc: -> untyped
    def initializers: -> spec_hash
    def locals: { (String) -> void } -> void
    def name: -> untyped
    def param_list: -> untyped
    def qualified_name: -> String
    def resolved_return: -> Wrapture::TypeSpec
    def return_expression: (?func_name: String) -> String
    def signature: (?func_name: String) -> String
    def static?: -> bool
    def resolve_type: (untyped type_) -> untyped
    def return_overloaded?: -> bool
    def returns_call_directly?: -> bool
    def variadic?: -> bool
    def virtual?: -> bool

    private
    def capture_return?: -> bool
    def returns_return_val?: -> bool
  end
end
