module Wrapture
  class FunctionSpec
    @owner: untyped
    @spec: spec_hash
    @wrapped: Wrapture::WrappedFunctionSpec | Wrapture::WrappedCodeSpec | nil
    @params: Array[Wrapture::ParamSpec]
    @constructor: bool
    @destructor: bool

    def self.normalize_return_hash: (Hash[String, untyped] spec) -> Hash[String, untyped]
    def self.normalize_spec_hash: (Hash[String, untyped] spec) -> Hash[String, untyped]
    def initialize: (untyped spec, ?untyped owner, ?constructor: bool, ?destructor: bool) -> void
    attr_reader params: Array[Wrapture::ParamSpec]
    attr_reader return_type: Wrapture::TypeSpec
    attr_reader wrapped: Wrapture::WrappedFunctionSpec | Wrapture::WrappedCodeSpec | nil
    def constructor?: -> boolish
    def declaration_includes: -> Array[String]
    def definable?: -> bool
    def definable!: -> true
    def definition_includes: -> Array[String]
    def doc: -> untyped
    def locals: { (String) -> void } -> void
    def name: -> untyped
    def param_list: -> untyped
    def qualified_name: -> String
    def resolve_wrapped_param: (untyped param_spec) -> String
    def resolved_return: -> Wrapture::TypeSpec
    def return_expression: (?func_name: String) -> String
    def signature: (?func_name: String) -> String
    def static?: -> bool
    def resolve_type: (untyped type_) -> untyped
    def return_overloaded?: -> bool
    def returns_call_directly?: -> bool
    def variadic?: -> bool
    def virtual?: -> bool

    private
    def capture_return?: -> bool
    def castable?: (untyped wrapped_param) -> boolish
    def returns_return_val?: -> bool
  end
end
