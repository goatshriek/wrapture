module Wrapture
  class ClassSpec
    include Named

    @spec: spec_hash
    @constants: Array[Wrapture::ConstantSpec]
    @functions: Array[Wrapture::FunctionSpec]
    @doc: Wrapture::Comment
    @scope: Wrapture::Scope

    def self.effective_type: (spec_hash spec) -> String
    def self.normalize_spec_hash: (spec_hash spec, *Wrapture::TemplateSpec templates) -> spec_hash
    def self.normalize_spec_hash!: (spec_hash spec, *Wrapture::TemplateSpec templates) -> spec_hash
    attr_reader constants: Array[Wrapture::ConstantSpec]
    attr_reader doc: Wrapture::Comment
    attr_reader functions: Array[Wrapture::FunctionSpec]
    attr_reader scope: Wrapture::Scope
    attr_reader struct: (Wrapture::StructSpec | nil)
    def initialize: (spec_hash spec, ?scope: Wrapture::Scope) -> void
    def cast: (untyped var_name, untyped to, untyped from) -> String
    def child?: -> bool
    def declaration_includes: -> Array[String]
    def definition_includes: -> Array[String]
    def documentation: { (String) -> void } -> void
    def equivalent_member?: -> bool
    def factory?: -> bool
    def libraries: -> Array[String]
    def name: -> String
    def namespace: -> String
    def overloads?: (untyped parent_spec) -> bool
    def parent_name: -> (String | nil)
    def parent_provides_initializer?: -> bool
    def pointer_wrapper?: -> bool
    def snake_case_name: -> String
    def struct_name: -> String
    def type: (Wrapture::TypeSpec) -> Wrapture::ClassSpec
    def type?: (Wrapture::TypeSpec) -> bool

    private
    def factory_definition_includes: -> Array[String]
  end
end
