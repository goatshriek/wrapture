# SPDX-License-Identifier: Apache-2.0

# frozen_string_literal: true

#--
# Copyright 2021 Joel E. Anderson
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#++

module Wrapture
  # A wrapper that generates Python wrappers for given specs.
  class PythonWrapper
    # Generates the setup.py script and other supporting files for the
    # given spec. These can be used to package the files generated by
    # +write_source_files+. This is equivalent to instantiating a wrapper
    # with the spec and then calling write_setuptools_files on that.
    def self.write_spec_setuptools_files(spec, **kwargs)
      wrapper = new(spec)
      wrapper.write_setuptools_files(kwargs)
    end

    # Generates C source files that form a Python extension, returning a
    # list of the files generated. This is equivalent to instantiating a
    # wrapper with the given spec, and then calling write_source_files on that.
    def self.write_spec_source_files(spec, **kwargs)
      wrapper = new(spec)
      wrapper.write_source_files(**kwargs)
    end

    # Creates a C++ wrapper for a given spec.
    def initialize(spec)
      @spec = spec
    end

    # Generates the setup.py script and other supporting files for this
    # instance's spec. These can be used to package the files generated by
    # +write_source_files+.
    def write_setuptools_files(dir: Dir.pwd)
      File.open(File.join(dir, 'setup.py'), 'w') do |file|
        file.puts <<~SETUPTEXT
          from distutils.core import setup, Extension

          module1 = Extension('spam',
                              sources = ['BasicClass.c'])

          setup (name = 'spam',
                 version = '1.0',
                 description = 'This is a demo package',
                 ext_modules = [module1])
        SETUPTEXT
      end
    end

    # Generates C source files that form an extension module of Python with
    # the functionality of this instance's spec, returning a list of the
    # files generated. +dir+ specifies the directory that the files should
    # be written into. The default is the current working directory.
    def write_source_files(dir: Dir.pwd)
      filename = "#{@spec.name}.c"

      File.open(File.join(dir, filename), 'w') do |file|
        file.puts <<~SOURCETEXT
          #define PY_SSIZE_T_CLEAN
          #include <Python.h>

          static PyObject *
          spam_system(PyObject *self, PyObject *args)
          {
              const char *command;
              int sts;

              if (!PyArg_ParseTuple(args, "s", &command))
                  return NULL;
              sts = system(command);
              return PyLong_FromLong(sts);
          }

          static PyMethodDef SpamMethods[] = {
            {"system",  spam_system, METH_VARARGS,
             "Execute a shell command."},
            {NULL, NULL, 0, NULL}        /* Sentinel */
          };

          static struct PyModuleDef spammodule = {
            PyModuleDef_HEAD_INIT,
            "spam",   /* name of module */
            NULL, /* module documentation, may be NULL */
            -1,       /* size of per-interpreter state of the module,
                         or -1 if the module keeps state in global variables. */
            SpamMethods
          };

          PyMODINIT_FUNC
          PyInit_spam(void)
          {
              return PyModule_Create(&spammodule);
          }
        SOURCETEXT
      end

      filename
    end
  end
end
